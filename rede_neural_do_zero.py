# -*- coding: utf-8 -*-
"""Rede-neural-do-zero.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tIgljVR8o7K2VG1MyPRrYCQmAZVVK_B5
"""

import numpy as np
import torch
import torch.nn.functional as F
import torchvision
import matplotlib
import matplotlib.pyplot as plt
from time import time
from torchvision import datasets, transforms
from torch import nn, optim

transform = transforms.ToTensor() #Definindo a conversçao de imagem para tensor

trainset = datasets.MNIST('./MNIST_data', download=True, train=True, transform=transform) #Carrega a parte de treino do dataset
trainloader = torch.utils.data.DataLoader(trainset, batch_size=64, shuffle=True) #Cria um buffar para pegar os dados por partes

valset = datasets.MNIST('./MNIST_data', download=True, train=False, transform=transform) #Carrega a parte de validação do dataset
valloader = torch.utils.data.DataLoader(valset, batch_size=64, shuffle=True) #Cria um buffer para pegar os dados por partes

for imagens, etiquetas in trainloader:
    plt.imshow(imagens[0].numpy().squeeze(), cmap='gray_r')
    break  # Para mostrar apenas uma imagem de exemplo, remova essa linha se quiser iterar sobre mais imagens

print(imagens[0].shape) #Para verificar as dimensões do tensor de cada imagem
print(etiquetas[0].shape) #Para verificar as dimensões do tensor de cada etiqueta

class Modelo(nn.Module):
  def __init__(self):
     super(Modelo, self).__init__()
     self.linear0 = nn.Linear(28*28, 128) #Camada de entrada, 784 neurônios que se ligam a 128
     self.linear1 = nn.Linear(128, 64) #Camada interna 1, 128 neurônios que se ligam a 64
     self.linear2 = nn.Linear(64, 10) #Camada interna 2, 64 neurônios que se ligam a 10
     #Para a camada de saída não é necessário definir nada, pois só precisamos pegar o output ca camada interna 2

  def forward(self, x):
    X = F.relu(self.linear0(X)) #Função de ativação da camada de entrada para a camada interna 1
    X = F.relu(self.linear1(X)) #Função de ativação da camada de entrada para a camada interna 2
    X = self.linear2(X) #Função de ativação da cama interna 2, para a camada de saída, nesse caso f(x) = x
    return F.log_softmax(X, dim=1) #Dados utilizados para calcular a perda

def treino(modelo, trainloader, device):
  otimizador = optim.SGD(modelo.parameters(), lr=0.01, momentum=0.5) #Define a politica de atualização dos pesoas e da bias
  inicio = time() #Timer para sabermos quanto tempo levou o treino

  criterio = nn.NLLLoss() #Definindo o critério para calcular a perda
  EPOCHS = 10 #Número de epochs que o algoritmo rodará
  modelo.train() #Ativando o modo de treinamento do modelo

  for epoch in range(EPOCHS):
    perda_acumulada = 0 #Inicialização da perda acumulada da epoch em questão

    for imagens, etiquetas in trainloader:

      imagens = imagens.view(imagens.shape[0], -1) #Convertendo as imagens para "vetores" de 28*28 casas para ficarem compativeis com a
      otimizador.zero_grad() #Gerando os gradientes por conta do ciclo anterior

      output = modelo(imagens.to(device)) #Colocando os dados no modelo
      perda_instantanea = criterio(output, etiquetas.to(device)) #Calculando a perda da epoch em questão

      perda_instantanea.backward() #Back prototipagem a parir da perda

      otimizador.step() #Atualizando os pesos e as bias

      perda_acumulada += perda_instantanea.item() #Atualização da perda acumulada

    else:
      print(f"Epoch {epoch+1} - Perda resultante: {perda_acumulada/len(trainloader)}")
  print(f"\nTempo de treino em minutos = {(time()-inicio)/60}")

def validacao(modelo, valloader, device):
  conta_corretas, conta_todas = 0, 0
  for imagens, etiquetas in valloader:
    for i in range(len(etiquetas)):
      img = imagens[i].view(1, 784)
      #Desativar o autograd para acelerar a validação. Grafos computacioanis tem um alto custo de processamento
      with torch.no_grad():
        logps = modelo(img.to(device)) #Output do modelo em escala logaritmica

        ps = torch.exp(logps) #Converte output para escala normal (lembrando que é um tensor)
        probab = list(ps.cpu().numpy()[0])
        etiqueta_pred = probab.index(max(probab)) #Converte o tensor em um número, no caso, o número que o modelo previu
        etiqueta_certa = etiquetas.numpy()[i]
        if (etiqueta_certa == etiqueta_pred): #Compara a previsão com o valor correto
          conta_corretas += 1
        conta_todas += 1
      print(f"Total de imagens testadas: {conta_todas}")
      print(f"\nPrecisão do modelo = {conta_corretas*100/conta_todas}%")

modelo = Modelo() #Inicializa o modelo

device = torch.device("cuda" if torch.cuda.is_available() else "cpu") #Modelo rodará na GPU se possível
modelo.to(device)